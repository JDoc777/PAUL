import serial
import json
import time
import numpy as np
import threading
from queue import Queue, Empty
import sys
import math


# Configure UART
serial_port = "/dev/ttyAMA0"  # UART port
baud_rate = 250000           # Baud rate

# Initialize serial communication
ser = serial.Serial(serial_port, baud_rate, timeout=1)

# Global variables for angle calculation
theta = 0.0          # Robot's rotation angle in degrees
gyro_offset = 0.0    # Offset to correct gyro drift
gyro_threshold = 0.0 # Threshold to ignore small gyro values
last_time = None     # Last timestamp for integration
alpha = 0.95         # Low-pass filter weight (0.0 < alpha < 1.0)

# Lock and queue for thread synchronization
gyro_queue = Queue(maxsize=200)  # Increased queue size to hold more gyro data
print_queue = Queue()

# Declare pos as a global variable for encoder ticks
pos = [0, 0, 0, 0]  # Encoder ticks for each wheel: [fl, fr, bl, br]

# Position tracking (x, y, theta in global frame)
x, y = 0.0, 0.0  # Initial position and orientation in global frame

encoder_state = {
    'FL': {'last_encoder_pos': 0, 'last_time': time.time()},
    'FR': {'last_encoder_pos': 0, 'last_time': time.time()},
    'BL': {'last_encoder_pos': 0, 'last_time': time.time()},
    'BR': {'last_encoder_pos': 0, 'last_time': time.time()}
}

# Global variable for encoder position updates (simulating sensor data)
encoderPos_FL = 0
encoderPos_FR = 0
encoderPos_BL = 0
encoderPos_BR = 0

def update_encoder_position(wheel, current_encoder_pos):
    """
    Update the encoder position and calculate the time interval for a given wheel.
    
    :param wheel: Wheel identifier (e.g., 'FL', 'FR', 'BL', 'BR')
    :param current_encoder_pos: Current encoder position for the wheel
    :return: prev_pos, current_pos, delta_t
    """
    global encoder_state

    # Get the current timestamp
    current_time = time.time()

    # Calculate delta_t (time difference)
    delta_t = current_time - encoder_state[wheel]['last_time']

    # Store the previous position
    prev_pos = encoder_state[wheel]['last_encoder_pos']

    # Update the last encoder position and timestamp for the wheel
    encoder_state[wheel]['last_encoder_pos'] = current_encoder_pos
    encoder_state[wheel]['last_time'] = current_time

    return prev_pos, current_encoder_pos, delta_t


def calculate_velocity(prev_pos, current_pos, delta_t):
    """
    Calculate velocity based on encoder data.
    
    :param prev_pos: Previous encoder position
    :param current_pos: Current encoder position
    :param delta_t: Time interval in seconds
    :return: Velocity in meters per second
    """
    # Constants
    radius = 0.04  # Radius in meters (40 mm)
    pulses_per_revolution = 111.25  # Pulses per revolution (PPR)

    # Calculate the change in encoder position
    delta_n = current_pos - prev_pos

    # Calculate velocity using the formula
    velocity = (2 * math.pi * radius * delta_n) / (pulses_per_revolution * delta_t)
    return velocity

def calculate_velocity_components(Vfr, Vfl, Vrr, Vrl):
    """
    Calculate the velocity components in the x and y directions.
    
    :param Vfr: Velocity of front-right wheel
    :param Vfl: Velocity of front-left wheel
    :param Vrr: Velocity of rear-right wheel
    :param Vrl: Velocity of rear-left wheel
    :param R: Radius of the wheels in meters
    :return: Vx and Vy velocities in the x and y directions
    """
    R = 0.04
    
    Vx = (R / 4) * (Vfr - Vfl - Vrr + Vrl)
    Vy = (R / 4) * (Vfr + Vfl + Vrr + Vrl)
    
    return Vx, Vy

def update_velocity():
    global encoderPos_FL
    global encoderPos_FR
    global encoderPos_BL
    global encoderPos_BR
    
    while True:
        
        # Get the previous position, current position, and delta_t for each wheel
        prev_pos_FL, current_pos_FL, delta_t_FL = update_encoder_position('FL', encoderPos_FL)
        prev_pos_FR, current_pos_FR, delta_t_FR = update_encoder_position('FR', encoderPos_FR)
        prev_pos_BL, current_pos_BL, delta_t_BL = update_encoder_position('BL', encoderPos_BL)
        prev_pos_BR, current_pos_BR, delta_t_BR = update_encoder_position('BR', encoderPos_BR)

        # Calculate velocity for each wheel based on the updated position data
        velocity_FL = calculate_velocity(prev_pos_FL, current_pos_FL, delta_t_FL)
        velocity_FR = calculate_velocity(prev_pos_FR, current_pos_FR, delta_t_FR)
        velocity_BL = calculate_velocity(prev_pos_BL, current_pos_BL, delta_t_BL)
        velocity_BR = calculate_velocity(prev_pos_BR, current_pos_BR, delta_t_BR)
        
        # Calculate the x and y velocity components
        Vx, Vy = calculate_velocity_components(velocity_FR, velocity_FL, velocity_BL, velocity_BR)

        # Print the results for each wheel
        print_queue.put(f"FL Velocity: {velocity_FL:.2f} m/s, FR Velocity: {velocity_FR:.2f} m/s, "
              f"BL Velocity: {velocity_BL:.2f} m/s, BR Velocity: {velocity_BR:.2f} m/s")
        print_queue.put(f"Vx (X Velocity): {Vx:.2f} m/s, Vy (Y Velocity): {Vy:.2f} m/s")
        
        # Simulate some delay to mimic the sensor updates
        time.sleep(0.1)

def print_safe():
    while True:
        try:
            # Try to get a message from the queue
            message = print_queue.get(timeout=0.02)  # Adjust timeout if necessary
            sys.stdout.write(message + '\n')  # Ensures printing with a newline
            sys.stdout.flush()  # Force flushing immediately
        except Empty:
            continue  # If queue is empty, keep checking

# Function to calculate gyro offset and noise threshold
def calculate_gyro_offset(samples=200):
    global gyro_offset, gyro_threshold
    print_queue.put("Calculating gyro offset...")
    offsets = []
    for _ in range(samples):
        if ser.in_waiting > 0:
            line = ser.readline().decode('utf-8', errors='ignore').strip()  # Decode with error handling
            try:
                data = json.loads(line)
                if 'gyro' in data and 'z' in data['gyro']:
                    gyro_z = data['gyro']['z']
                    offsets.append(gyro_z)
                else:
                    print_queue.put("Gyro data not found or missing 'z' key.")
            except (json.JSONDecodeError, KeyError) as e:
                print_queue.put(f"Error parsing data: {e}")
        
        time.sleep(0.01)  # Adding a small delay to avoid flooding the serial buffer
    
    if offsets:
        # Calculate the standard deviation of the collected offsets
        offsets = np.array(offsets)
        gyro_offset = np.median(offsets)  # Use median for offset calculation
        gyro_threshold = np.std(offsets) * 2  # Set threshold to 2x the standard deviation
        print_queue.put(f"Gyro offset calculated: {gyro_offset}")
        print_queue.put(f"Gyro noise threshold calculated: {gyro_threshold}")
    else:
        print_queue.put("Failed to calculate gyro offset. No valid data received.")

def update_theta():
    global theta, last_time, gyro_offset, gyro_threshold
    last_gyro_z = 0.0  # Store last gyro value for filtering
    while True:
        try:
            # Check if queue has data
            if not gyro_queue.empty():
                gyro_z = gyro_queue.get_nowait()  # Non-blocking

                current_time = time.time()
                if last_time is None:
                    last_time = current_time
                    continue
                delta_time = current_time - last_time
                last_time = current_time

                # Ignore gyro values smaller than the threshold
                if abs(gyro_z) < gyro_threshold:
                    gyro_z = 0  # Zero out small gyro readings to ignore noise

                # Low-pass filter for gyro_z (if desired)
                smoothed_gyro_z = alpha * gyro_z + (1 - alpha) * last_gyro_z
                last_gyro_z = smoothed_gyro_z  # Store the last value for the next iteration

                # Correct for drift using smoothed gyro_z
                angular_velocity = smoothed_gyro_z - gyro_offset

                # Apply small decay to reduce drift over time
                if abs(angular_velocity) < 0.01:  # Reduced threshold to treat as "zero velocity"
                    angular_velocity = 0

                # Integrate angular velocity to get angle
                theta += angular_velocity * delta_time
                theta %= 360  # Keep theta within [0, 360) degrees

                # Print the updated angle
                print_queue.put(f"Current Angle (theta): {theta:.2f} degrees")
                
            time.sleep(0.01)  # Shorter sleep to reduce lag
        except Empty:
            continue  # If queue is empty, continue the loop

def read_and_parse_serial():
    global encoderPos_FL
    global encoderPos_FR
    global encoderPos_BL
    global encoderPos_BR
    while True:
        try:
            if ser.in_waiting > 0:
                line = ser.readline().decode('utf-8', errors='ignore').strip()  # Decode with error handling
                
                if line:
                    print_queue.put(f"Raw data: {line}")  # Print the raw incoming data
                    
                    try:
                        # Parse JSON data
                        data = json.loads(line)
                        
                        # Extract various sensor data (adjust to match your actual structure)
                        distance_f = data['distance']['F']
                        distance_b = data['distance']['B']
                        distance_l = data['distance']['L']
                        distance_r = data['distance']['R']
                
                        gyro_x = data['gyro']['x']
                        gyro_y = data['gyro']['y']
                        gyro_z = data['gyro']['z']
                
                        accel_x = data['accel']['x']
                        accel_y = data['accel']['y']
                        accel_z = data['accel']['z']
                
                        encoderPos_FL = data['enco']['1']['position']
                        encoderPos_FR = data['enco']['2']['position']
                        encoderPos_BL = data['enco']['3']['position']
                        encoderPos_BR = data['enco']['4']['position']

                        rotation_1 = data['enco']['1']['rotation']
                        rotation_2 = data['enco']['2']['rotation']
                        rotation_3 = data['enco']['3']['rotation']
                        rotation_4 = data['enco']['4']['rotation']

                        temperature = data['environment']['temperature']
                        humidity = data['environment']['humidity']
                
                        # Print parsed data
                        print_queue.put(f"Distances - L: {distance_l}, R: {distance_r}, B: {distance_b}, F: {distance_f}")
                        print_queue.put(f"Gyro - X: {gyro_x}, Y: {gyro_y}, Z: {gyro_z}")
                        print_queue.put(f"Accel - X: {accel_x}, Y: {accel_y}, Z: {accel_z}")
                        print_queue.put(f"Encoder 1 - Position: {encoderPos_FL}, Rotation: {rotation_1}")
                        print_queue.put(f"Encoder 2 - Position: {encoderPos_FR}, Rotation: {rotation_2}")
                        print_queue.put(f"Encoder 3 - Position: {encoderPos_BL}, Rotation: {rotation_3}")
                        print_queue.put(f"Encoder 4 - Position: {encoderPos_BR}, Rotation: {rotation_4}")
                        print_queue.put(f"Environment - Temperature: {temperature}°C, Humidity: {humidity}%")
                        gyro_queue.put(gyro_z)  # Add gyro_z to the queue
                    except json.JSONDecodeError:
                        print_queue.put("Error: Received invalid JSON data.")
                    except KeyError as e:
                        print_queue.put(f"Error: Missing key in JSON data - {e}")
                else:
                    print_queue.put("No data received.")
            time.sleep(0.01)  # Reduced delay to prevent lag
        except Exception as e:
            print_queue.put(f"Error while reading serial data: {e}")

# Function to send JSON data
def send_data():
    global theta
    while True:
        # Example data to send
        fl, fr, bl, br = theta, 2, 77, 314  # Replace with actual logic
        # Create a dictionary with the variables
        data = {
            "FL": fl,
            "FR": fr,
            "BL": bl,
            "BR": br
        }
        # Convert dictionary to JSON string
        json_data = json.dumps(data)
        # Send JSON string over UART
        ser.write((json_data + "\n").encode('utf-8'))
        
        print_queue.put(f"Data sent: {data}")
        time.sleep(0.05)  # Send data periodically

# Main function
def main():
    print_queue.put("Starting UART communication...")

    # Calculate gyro offset before starting
    calculate_gyro_offset()

    # Start threads for reading, writing, and updating theta
    read_thread = threading.Thread(target=read_and_parse_serial, daemon=True)
    write_thread = threading.Thread(target=send_data, daemon=True)
    theta_thread = threading.Thread(target=update_theta, daemon=True)
    print_thread = threading.Thread(target=print_safe, daemon=True)
    position_thread = threading.Thread(target=update_velocity, daemon=True)

    read_thread.start()
    write_thread.start()
    theta_thread.start()
    print_thread.start()
    position_thread.start()

    try:
        while True:
            time.sleep(0.01)  # Keep the main thread alive
    except KeyboardInterrupt:
        print_queue.put("Stopping communication...")
    finally:
        ser.close()

if __name__ == "__main__":
    main()
