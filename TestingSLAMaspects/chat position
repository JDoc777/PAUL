import serial
import json
import time
import numpy as np

# Configure UART
serial_port = "/dev/ttyAMA0"  # UART port
baud_rate = 250000            # Baud rate

# Initialize serial communication
ser = serial.Serial(serial_port, baud_rate, timeout=1)

# Global variables for angle calculation
theta = 0.0          # Robot's rotation angle in radians
x = 0.0              # Robot's x position in meters
y = 0.0              # Robot's y position in meters
last_time = None     # Last timestamp for integration
alpha = 0.95         # Low-pass filter weight (0.0 < alpha < 1.0)

# Wheel parameters
wheel_radius = 0.04   # Wheel radius in meters (40mm)
wheel_base = 0.2      # Wheel base in meters (20cm)

# Encoder variables (to store last encoder positions)
last_encoder_1 = 0
last_encoder_2 = 0
last_encoder_3 = 0
last_encoder_4 = 0

# Function to calculate gyro offset and noise threshold
def calculate_gyro_offset(samples=200):
    global gyro_offset, gyro_threshold
    print("Calculating gyro offset...")
    offsets = []
    for _ in range(samples):
        if ser.in_waiting > 0:
            line = ser.readline().decode('utf-8', errors='ignore').strip()  # Decode with error handling
            try:
                data = json.loads(line)
                if 'gyro' in data and 'z' in data['gyro']:
                    gyro_z = data['gyro']['z']
                    offsets.append(gyro_z)
                else:
                    print("Gyro data not found or missing 'z' key.")
            except (json.JSONDecodeError, KeyError) as e:
                print(f"Error parsing data: {e}")
        
        time.sleep(0.01)
    
    if offsets:
        offsets = np.array(offsets)
        gyro_offset = np.median(offsets)  # Use median for offset calculation
        gyro_threshold = np.std(offsets) * 2  # Set threshold to 2x the standard deviation
        print(f"Gyro offset calculated: {gyro_offset}")
        print(f"Gyro noise threshold calculated: {gyro_threshold}")
    else:
        print("Failed to calculate gyro offset. No valid data received.")

# Function to update the robot's rotation angle
def update_theta(gyro_z):
    global theta, last_time, gyro_offset, gyro_threshold
    current_time = time.time()
    
    # Ensure delta_time is calculated only after the first valid timestamp
    if last_time is None:
        last_time = current_time
        return 0  # Return 0 for the first call, no delta_time yet
    
    delta_time = current_time - last_time
    if delta_time == 0:  # Prevent division by zero
        return 0
    
    last_time = current_time

    if abs(gyro_z) < gyro_threshold:
        gyro_z = 0  # Zero out small gyro readings to ignore noise

    smoothed_gyro_z = alpha * gyro_z + (1 - alpha) * gyro_z
    angular_velocity = smoothed_gyro_z - gyro_offset

    if abs(angular_velocity) < 0.01:
        angular_velocity = 0

    theta += angular_velocity * delta_time
    theta %= 360  # Keep theta within [0, 360) degrees
    theta = np.radians(theta)  # Convert to radians for kinematic calculations
    return delta_time

# Function to read and parse incoming serial data
def read_and_parse_serial():
    global x, y, theta, last_encoder_1, last_encoder_2, last_encoder_3, last_encoder_4

    try:
        if ser.in_waiting > 0:
            line = ser.readline().decode('utf-8', errors='ignore').strip()

            if line:
                data = json.loads(line)
                
                # Encoder data
                encoderPos_1 = data['enco']['1']['position']
                encoderPos_2 = data['enco']['2']['position']
                encoderPos_3 = data['enco']['3']['position']
                encoderPos_4 = data['enco']['4']['position']
                
                # Gyro data
                gyro_z = data['gyro']['z']
                
                # Update theta with gyro_z and get delta_time
                delta_time = update_theta(gyro_z)

                if delta_time == 0:
                    return  # Skip update if delta_time is zero

                # Calculate wheel displacements in meters
                distance_1 = (encoderPos_1 - last_encoder_1) * (2 * np.pi * wheel_radius)
                distance_2 = (encoderPos_2 - last_encoder_2) * (2 * np.pi * wheel_radius)
                distance_3 = (encoderPos_3 - last_encoder_3) * (2 * np.pi * wheel_radius)
                distance_4 = (encoderPos_4 - last_encoder_4) * (2 * np.pi * wheel_radius)

                # Update wheel velocities (change in position over time)
                V1 = distance_1 / delta_time
                V2 = distance_2 / delta_time
                V3 = distance_3 / delta_time
                V4 = distance_4 / delta_time

                # Compute linear velocities in x and y direction
                Vx = (wheel_radius / 4) * (V1 + V2 + V3 + V4)
                Vy = (wheel_radius / 4) * (-V1 + V2 + V3 - V4)

                # Update robot's position
                delta_x = Vx * np.cos(theta) - Vy * np.sin(theta)
                delta_y = Vx * np.sin(theta) + Vy * np.cos(theta)

                # Update position with respect to previous position
                x += delta_x
                y += delta_y

                # Update last encoder positions
                last_encoder_1 = encoderPos_1
                last_encoder_2 = encoderPos_2
                last_encoder_3 = encoderPos_3
                last_encoder_4 = encoderPos_4

                # Print updated position and theta
                print(f"Current Position - X: {x:.2f}m, Y: {y:.2f}m, Theta: {np.degrees(theta):.2f}Â°")

    except json.JSONDecodeError:
        print("Error: Received invalid JSON data.")
    except KeyError as e:
        print(f"Error: Missing key in JSON data - {e}")

# Main loop to send and receive data
def main():
    global x, y, theta

    print("Starting UART communication...")

    # Calculate gyro offset before starting
    calculate_gyro_offset()

    try:
        while True:
            # Read and parse incoming data
            read_and_parse_serial()

            # Sleep for a short time to allow other tasks
            time.sleep(0.01)  # Adjust as needed for your application

    except KeyboardInterrupt:
        print("Stopping communication...")
    finally:
        ser.close()

if __name__ == "__main__":
    main()

