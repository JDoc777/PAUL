import serial
import json
import time
import matplotlib.pyplot as plt
import numpy as np

# Configure UART
serial_port = "/dev/ttyAMA0"  # UART port
baud_rate = 115200           # Baud rate

# Initialize serial communication
ser = serial.Serial(serial_port, baud_rate, timeout=1)

# Initialize variables for tracking data transmission rate
line_count = 0
start_time = time.time()

# Set up the plot
plt.ion()  # Enable interactive mode
fig, ax = plt.subplots()
robot_radius = 10  # Radius of the robot for visualization

# Draw robot at the center
robot_circle = plt.Circle((0, 0), robot_radius, color='blue', label="Robot")
ax.add_artist(robot_circle)
ax.set_xlim(-200, 200)  # Set plot limits (adjust for your environment)
ax.set_ylim(-200, 200)
ax.set_aspect('equal', adjustable='datalim')
ax.grid(True)
ax.legend()

# List to store the plotted points
all_points = []

# Initialize orientation (yaw)
orientation = 0  # Start at 0 degrees
prev_time = time.time()  # Store the previous timestamp for time-based integration

# Function to update the plot with walls or obstacles
def update_environment(distances):
    global all_points, orientation
    # Convert distances to polar coordinates and rotate according to robot orientation
    sensor_data = {
        "F": distances["F"],
        "B": distances["B"],
        "L": distances["L"],
        "R": distances["R"]
    }

    # Rotation matrix to rotate a point by orientation (in degrees)
    def rotate_point(x, y, theta):
        theta_rad = np.radians(theta)  # Convert angle to radians
        x_rot = x * np.cos(theta_rad) - y * np.sin(theta_rad)
        y_rot = x * np.sin(theta_rad) + y * np.cos(theta_rad)
        return x_rot, y_rot
    
    # Plot the sonar sensor points, applying the orientation rotation
    for direction, distance in sensor_data.items():
        if distance > 0:  # Only plot if the distance is positive (valid)
            # Calculate the angle based on the sensor direction
            angle = 0  # Initialize angle
            if direction == "F":
                angle = 0  # Front is at 0 degrees
            elif direction == "B":
                angle = 180  # Back is at 180 degrees
            elif direction == "L":
                angle = 90  # Left is at 90 degrees
            elif direction == "R":
                angle = -90  # Right is at -90 degrees

            # Rotate angle by robot's orientation
            rotated_angle = angle + orientation

            # Convert polar coordinates (distance, angle) to Cartesian coordinates
            x = distance * np.cos(np.radians(rotated_angle))
            y = distance * np.sin(np.radians(rotated_angle))

            # Rotate the point based on the robot's orientation
            x_rot, y_rot = rotate_point(x, y, orientation)

            # Store the rotated point to the list
            all_points.append((x_rot, y_rot))

    # Update the plot by plotting all the accumulated points
    ax.clear()  # Clear previous points (but not the robot)
    ax.add_artist(robot_circle)
    x_vals, y_vals = zip(*all_points)  # Extract x and y coordinates
    ax.plot(x_vals, y_vals, 'o', label="Obstacle Points")  # Plot all the points
    ax.set_xlim(-200, 200)
    ax.set_ylim(-200, 200)
    ax.set_aspect('equal', adjustable='datalim')
    ax.grid(True)
    ax.legend()
    plt.draw()
    plt.pause(0.01)

# Function to send JSON data
def send_data(fl, fr, bl, br):
    data = {
        "FL": fl,
        "FR": fr,
        "BL": bl,
        "BR": br
    }
    json_data = json.dumps(data)
    ser.write((json_data + "\n").encode('utf-8'))

# Function to read and parse incoming serial data
def read_and_parse_serial():
    global line_count, start_time, orientation, prev_time
    try:
        line = ser.readline().decode('utf-8').strip()
        if line:
            line_count += 1
            data = json.loads(line)
            
            # Extract distance data
            distances = {
                "F": data['distance']['F'],
                "B": data['distance']['B'],
                "L": data['distance']['L'],
                "R": data['distance']['R']
            }

            # Extract accelerometer and gyroscope data to calculate orientation
            gyro_z = data['gyro']['z']  # Gyro in degrees per second

            # Get current time to calculate time elapsed
            current_time = time.time()
            delta_time = current_time - prev_time
            prev_time = current_time

            # Update orientation by integrating the gyro data (in degrees per second)
            orientation += gyro_z * delta_time  # Integrate angular velocity

            # Normalize orientation to keep it within 0-360 degrees
            if orientation >= 360:
                orientation -= 360
            elif orientation < 0:
                orientation += 360

            # Print distances and orientation for debugging
            print(f"Distances - F: {distances['F']} B: {distances['B']} L: {distances['L']} R: {distances['R']}")
            print(f"Orientation: {orientation}Â°")
            
            # Update the plot with the new sensor data and orientation
            update_environment(distances)

            # Calculate transmission rate every 5 seconds
            elapsed_time = time.time() - start_time
            if elapsed_time >= 5:
                transmission_rate = line_count / elapsed_time
                print(f"Transmission Rate: {transmission_rate:.2f} lines/sec")
                line_count = 0
                start_time = time.time()
        else:
            print("No data received.")
    except json.JSONDecodeError:
        print("Invalid JSON received.")
    except KeyError as e:
        print(f"Missing data in JSON: {e}")

# Main loop to send and receive data
def main():
    print("Starting UART communication and plotting...")
    iteration_counter = 0
    start_time_iter = time.time()

    try:
        while True:
            # Read and parse incoming data
            read_and_parse_serial()
            
            # Example values for FL, FR, BL, BR to send
            fl = 222  # Replace with actual value
            fr = -100 # Replace with actual value
            bl = 180  # Replace with actual value
            br = -50  # Replace with actual value
            
            # Send data periodically
            send_data(fl, fr, bl, br)
            
            # Calculate and print iteration speed (iterations per second)
            iteration_counter += 1
            elapsed_iter_time = time.time() - start_time_iter
            if elapsed_iter_time >= 1:  # Print every 1 second
                iterations_per_second = iteration_counter / elapsed_iter_time
                print(f"Iteration Speed: {iterations_per_second:.2f} iterations/sec")
                iteration_counter = 0
                start_time_iter = time.time()

            # Sleep for a short time to allow other tasks
            time.sleep(0.01)

    except KeyboardInterrupt:
        print("Stopping communication and plotting...")
    finally:
        ser.close()

if __name__ == "__main__":
    main()
